\chapter{Modello Computazionale}
Il programma realizzato \'e composto da un file eseguibile (simulatore.c) e di 
alcuni file dove sono contenute funzioni di appoggio. (\textit{event\_list}, 
\textit{arrival\_queue}, \textit{autocorrelation}, \textit{client\_req}, 
\textit{req\_queue}).
Il software sviluppato \'e codificato con il linguaggio \textit{C}.

\section{Simulatore.c}

Questo applicativo \'e il cuore del simulatore implementato. Tale programma 
sfrutta un'interfaccia testuale per interrogare l'utente circa la configurazione 
da adottare per la simulazione da eseguire. 
\'E possibile selezionare diverse opzioni:
\begin{itemize}
\item Scegliere la distribuzione da testare;
\item Scegliere se attivare o meno il meccanismo di gestione dell'overload;
\item Scegliere il seed per la generazione di numeri random;
\item Scegliere i parametri della simulazione: numero e lunghezza dei batch;
\item Scegliere se visualizzare lo stato della simulazione live.
\end{itemize}

I risultati prodotti dalla simulazione vengono trascritti su un file di tipo 
"\textit{.csv}"  in modo da dare all'utente una chiara ed equilibrata visione 
dei dati ottenuti.

\section{Event List}
La lista di eventi \'e costituita da strutture di tipo \textit{Event}, formate 
da un campo di tipo \textit{double}, che indica il time che rappresenta il tempo 
di occorrenza, un \textit{\_EVENT\_TYPE} type rappresentante il tipo di evento 
ed un puntatore \textit{next} alla struttura seguente.
Per merito della funzione \textbf{add\_event()} \'e possibile aggiungere eventi 
alla lista. Verranno inseriti seguendo un ordinamento crescente rispetto alla 
variabile time. Durante l'inserimento dei dati viene effettuato un controllo 
sulla consistenza degli stessi, cioè si controlla, con una funzione 
\textbf{event\_check()}, che il tempo sia un valore positivo e che il tipo di 
evento sia compreso tra 0 e 3.
Gli eventi vengono estratti dalla struttura attraverso la funzione 
\textbf{pop\_event()}, che preleva l'elemento in testa alla lista, restituendolo 
alla funzione chiamante.

\section{Arrival queue}
La coda di arrivi contiene la struttura di dati di riferimento, che permette la 
gestione degli arrivi nei vari centri quali: \textit{Front Server}, 
\textit{Back-End Server} e \textit{Centro Client}. La coda viene rappresentata 
con una semplice struttura dati formata da un tempo di arrivo e un puntatore 
all'elemento successivo. Le funzioni messe a disposizione per questa struttura 
di dati sono: \textit{arrival\_add()}, \textit{arrival\_pop()} e 
l'\textit{arrival\_print()}.
\begin{itemize}
\item \textbf{arrival\_add()}: genera un nuovo elemento contenente il tempo di 
arrivo in un determinato centro, scorre tutto il contenuto della lista generata, 
posizionando il nuovo nodo in fondo alla coda.
\item \textbf{arrival\_pop()}: permette l'estrazione dell'elemento meno recente 
della coda.
\item \textbf{arrival\_print()}: stampa lo stato della coda.
\end{itemize}

\section{Request queue}
Questa coda si basa sul concetto di richiesta: ogni sessione, una 
volta ammessa all'interno del sistema, definisce un numero di richieste compreso 
tra 5 e 35. Questa informazione viene inserita all'interno della coda delle 
richieste in modo da poter sfruttare i dati generati, per modellare gli utenti 
attivi durante la simulazione.
Sfruttando la funzione \textbf{enqueue\_req()} \'e possibile inserire tutte le 
richieste generate dalla nuova sessione vigente. Per poter rimuovere tale dato 
\'e possibile  utilizzare la \textbf{dequeue\_req()}.
Per verificare l'andamento di tale struttura dati \'e stata implementata la 
funzione \textbf{print\_req()}.

\section{Client request}
Qui \'e implementa una struttura dati in grado di propagare 
l'informazione circa il numero di richieste relative ad una sessione. Viene 
impiegata all'ingresso e all'uscita dal centro di client in quanto 
l'ordine di entrata \'e differente da quello di uscita.
Le funzioni di cui dispone questa struttura, sono: 
\textbf{add\_client\_req()}, \textbf{pop\_ClientReq()} e 
\textbf{print\_client\_req()}, esattamente identiche a quelle delle strutture precedenti

\section{File Manager}
La parte relativa al file manager gestisce tutto il flusso di dati da 
trascrivere  su un file di output. Composto da tre funzioni:
\begin{itemize}
\item \textbf{get\_date()}: permette di ottenere l'orario e la data correnti, da 
salvare sul file desiderato.
\item \textbf{open\_file()}: utilizzata per la creazione e l'apertura 
del file da salvare. Il nome del file viene creato utilizzato la funzione 
\textbf{get\_date()}, quindi contiene la data corrente della creazione più il tipo di 
distribuzione scelta durante la fase di setting.
\item \textbf{close\_file()}: adottata per chiudere il file una volta 
terminata la scrittura su di esso.
\end{itemize}

\section{Utils}
Il file \textbf{utils.h} contiene delle funzioni utilizzate per la pulizia della console 
e alcune funzioni per la manipolazione dei dati ottenuti al termine della simulazione.

\begin{comment}
\section{Autocorrelazione}
Al fine di calcolare l'autocorrelazione sui tempi di risposta del sistema con 
\textbf{LAG} pari a 20 \'e stato scritto un programma C che prende in input il 
file generato dal simulatore e restituisce i valori calcolati delle 
autocorrelazioni. Per il calcolo di queste si \'e usata la formula:

\vspace{0.5cm}
\begin{center} $r_{j} = \frac{c_{j}}{c_{0}} con j = 1,2,...20$\end{center}

\section{Intervalli di confidenza}
\'E stato sviluppato un programma scritto in linguaggio \textbf{C} allo scopo di 
calcolare gli intervalli di confidenza di livello 1 - \textalpha, dove 
\textalpha è pari al 5\%. Tale programma prende in input un file in cui sono 
scritti tutti i valori su cui si vuole fare il calcolo e computa le seguenti 
statistiche:
\begin{itemize}
 \item Calcolo della media: $\bar{x}_{i} = \frac{1}{i}(x_{i} - \bar{x}_{i-1})$;
 \item Calcolo della varianza: $v_{i} = v_{i-1} + (\frac{i-1}{i}){(x_{i} - 
\bar{x}_{i-1})}^{2}$;
 \item Calcolo del valore critico: $t^{*} = idfStudent(n-1, 
1-\frac{\textalpha}{2})$;
 \item Calcolo degli estremi dell'intervallo: $\bar{x} \pm 
\frac{t^{*}s}{\sqrt{n-1}}$;
\end{itemize}
\end{comment}